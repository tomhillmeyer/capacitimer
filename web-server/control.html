<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Capacitimer Control</title>
    <link rel="stylesheet" href="/shared-styles.css">
    <script src="/settings.js"></script>
    <style>
        /* Control page overrides */
        body {
            padding: 2rem;
            min-height: 100vh;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Capacitimer</h1>

        <div class="timer-display control">
            <div class="timer-value" id="timerValue">0:00</div>
            <div class="timer-status" id="timerStatus">READY</div>
        </div>

        <div class="section">
            <h2>Playback Controls</h2>
            <div class="button-group">
                <button class="btn-start" onclick="startTimer()">Start</button>
                <button class="btn-pause" onclick="pauseTimer()">Pause</button>
                <button class="btn-reset" onclick="resetTimer()">Reset</button>
            </div>
        </div>

        <div class="section">
            <h2>Quick Presets</h2>
            <div class="preset-buttons">
                <button class="btn-preset" onclick="setTimerPreset('bottomOfHour')">Bottom of Hour</button>
                <button class="btn-preset" onclick="setTimerPreset('topOfHour')">Top of Hour</button>
                <button class="btn-preset" onclick="setTimerPreset(60)">1 min</button>
                <button class="btn-preset" onclick="setTimerPreset(300)">5 min</button>
                <button class="btn-preset" onclick="setTimerPreset(600)">10 min</button>
                <button class="btn-preset" onclick="setTimerPreset(1800)">30 min</button>
                <button class="btn-preset" onclick="setTimerPreset(3600)">60 min</button>
                <button class="btn-preset" onclick="setTimerPreset(5400)">90 min</button>
            </div>
        </div>

        <div class="section">
            <h2>Adjustments</h2>
            <div class="button-group">
                <button class="btn-adjust" onclick="adjustTimer(-600)">-10 min</button>
                <button class="btn-adjust" onclick="adjustTimer(-300)">-5 min</button>
                <button class="btn-adjust" onclick="adjustTimer(-60)">-1 min</button>
                <button class="btn-adjust" onclick="adjustTimer(60)">+1 min</button>
                <button class="btn-adjust" onclick="adjustTimer(300)">+5 min</button>
                <button class="btn-adjust" onclick="adjustTimer(600)">+10 min</button>
            </div>
        </div>

        <div class="section">
            <h2>Custom Time</h2>
            <div class="custom-time">
                <input type="text" id="customTime" placeholder="MM:SS or HH:MM:SS" />
                <button class="btn-preset" onclick="setCustomTime()">Set Time</button>
            </div>
        </div>

        <div class="section">
            <h2>Count Down to Time</h2>
            <div class="custom-time">
                <input type="text" id="countDownTime" placeholder="e.g., 2:30 PM or 14:30" />
                <button class="btn-preset" onclick="setCountDownToTime()">Count Down</button>
            </div>
        </div>

        <div class="section">
            <h2>Settings</h2>
            <div style="display: grid; gap: 1rem;">
                <div>
                    <h3 style="font-size: 1.1rem; margin-bottom: 0.5rem; color: #aaa;">Display Units</h3>
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="checkbox" id="showHours" checked>
                            <span>Hours</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="checkbox" id="showMinutes" checked>
                            <span>Minutes</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="checkbox" id="showSeconds" checked>
                            <span>Seconds</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="checkbox" id="showMilliseconds">
                            <span>Milliseconds</span>
                        </label>
                    </div>
                </div>

                <div>
                    <h3 style="font-size: 1.1rem; margin-bottom: 0.5rem; color: #aaa;">Timer Colors</h3>
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap; align-items: center;">
                        <label style="display: flex; align-items: center; gap: 0.5rem;">
                            <span>Normal:</span>
                            <input type="color" id="colorNormal" value="#44ff44">
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem;">
                            <span>Warning:</span>
                            <input type="color" id="colorWarning" value="#ffaa00">
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem;">
                            <span>Critical:</span>
                            <input type="color" id="colorCritical" value="#ff4444">
                        </label>
                    </div>
                </div>

                <div>
                    <h3 style="font-size: 1.1rem; margin-bottom: 0.5rem; color: #aaa;">Display Options</h3>
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="checkbox" id="countUpAfterZero">
                            <span>Count up after 0</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="checkbox" id="showTimeOfDay" checked>
                            <span>Show time of day</span>
                        </label>
                    </div>
                </div>

                <div style="margin-top: 0.5rem;">
                    <p style="font-size: 0.9rem; color: #666;">Note: Settings are stored locally and will apply to all
                        displays</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let updateInterval;
        let localUpdateInterval;
        let cachedState = null;
        let ws = null;

        // WebSocket connection
        function connectWebSocket() {
            ws = new WebSocket('ws://localhost:3001');

            ws.onopen = () => {
                console.log('WebSocket connected');
            };

            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);

                if (message.type === 'timer-update') {
                    cachedState = message.data;
                    updateDisplay(message.data);
                } else if (message.type === 'settings-update') {
                    // Update settings from broadcast
                    Object.keys(message.data).forEach(key => {
                        settingsManager.set(key, message.data[key]);
                    });
                    // Update UI elements (without re-adding listeners)
                    updateSettingsUI();
                    // Update display with new settings
                    if (cachedState) {
                        updateDisplay(cachedState);
                    }
                }
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected, reconnecting...');
                setTimeout(connectWebSocket, 1000);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
        }

        // Broadcast settings changes to other clients
        async function broadcastSettings() {
            const settings = settingsManager.getAll();
            try {
                await fetch('/api/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                });
            } catch (error) {
                console.error('Failed to broadcast settings:', error);
            }
        }

        function formatTime(seconds) {
            return settingsManager.formatTime(seconds);
        }

        function getTimerColor(seconds) {
            return settingsManager.getTimerColor(seconds);
        }

        function formatTimeOfDay() {
            if (!settingsManager.get('showTimeOfDay')) {
                return '';
            }
            const now = new Date();
            let hours = now.getHours();
            const minutes = now.getMinutes();
            const ampm = hours >= 12 ? 'PM' : 'AM';

            hours = hours % 12;
            hours = hours ? hours : 12;

            return `${hours}:${minutes.toString().padStart(2, '0')} ${ampm}`;
        }

        function calculateTimeRemaining(state) {
            if (!state.isRunning || !state.endTime) {
                // Use pausedTimeRemaining to preserve milliseconds when paused
                return state.pausedTimeRemaining || state.timeRemaining;
            }

            const now = Date.now();
            const remainingMs = Math.max(0, state.endTime - now);
            return remainingMs / 1000; // Return fractional seconds for millisecond precision
        }

        function updateDisplay(state) {
            const timerValue = document.getElementById('timerValue');
            const timerStatus = document.getElementById('timerStatus');

            let timeRemaining = calculateTimeRemaining(state);

            // Handle count up after zero
            if (settingsManager.get('countUpAfterZero') && timeRemaining === 0 && state.isRunning) {
                // Calculate elapsed time since endTime
                const elapsed = Math.floor((Date.now() - state.endTime) / 1000);
                timeRemaining = -elapsed;
            }

            timerValue.textContent = formatTime(timeRemaining);
            timerValue.style.color = getTimerColor(Math.abs(timeRemaining));

            // Show time of day
            const timeOfDay = formatTimeOfDay();
            if (timeOfDay) {
                timerStatus.textContent = timeOfDay;
            } else {
                // Fallback to status if time of day is disabled
                if (state.isRunning) {
                    timerStatus.textContent = 'RUNNING';
                } else if (state.isPaused) {
                    timerStatus.textContent = 'PAUSED';
                } else if (Math.abs(timeRemaining) > 0) {
                    timerStatus.textContent = 'READY';
                } else {
                    timerStatus.textContent = "TIME'S UP";
                }
            }
        }

        async function fetchTimerState() {
            try {
                const response = await fetch('/api/timer');
                const state = await response.json();
                cachedState = state;
                updateDisplay(state);
            } catch (error) {
                console.error('Failed to fetch timer state:', error);
            }
        }

        function updateLocalDisplay() {
            if (cachedState && cachedState.isRunning) {
                updateDisplay(cachedState);
            }
        }

        async function startTimer() {
            try {
                const response = await fetch('/api/timer/start', { method: 'POST' });
                const data = await response.json();
                updateDisplay(data.state);
            } catch (error) {
                console.error('Failed to start timer:', error);
            }
        }

        async function pauseTimer() {
            try {
                // Optimistically update the cached state immediately to prevent flicker
                if (cachedState && cachedState.isRunning && cachedState.endTime) {
                    const now = Date.now();
                    const remainingMs = Math.max(0, cachedState.endTime - now);
                    const preciseRemaining = remainingMs / 1000;

                    cachedState = {
                        ...cachedState,
                        isRunning: false,
                        isPaused: true,
                        pausedTimeRemaining: preciseRemaining,
                        timeRemaining: Math.ceil(preciseRemaining),
                        endTime: null
                    };
                    updateDisplay(cachedState);
                }

                const response = await fetch('/api/timer/pause', { method: 'POST' });
                const data = await response.json();
                cachedState = data.state;
                updateDisplay(data.state);
            } catch (error) {
                console.error('Failed to pause timer:', error);
            }
        }

        async function resetTimer() {
            try {
                const response = await fetch('/api/timer/reset', { method: 'POST' });
                const data = await response.json();
                updateDisplay(data.state);
            } catch (error) {
                console.error('Failed to reset timer:', error);
            }
        }

        async function setTimer(seconds, keepRunning = false) {
            try {
                const response = await fetch('/api/timer/set', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ seconds, keepRunning })
                });
                const data = await response.json();
                updateDisplay(data.state);
            } catch (error) {
                console.error('Failed to set timer:', error);
            }
        }

        // Preset buttons should keep timer running if it's already running
        async function setTimerPreset(preset) {
            try {
                // Get current state to check if running
                const stateResponse = await fetch('/api/timer');
                const currentState = await stateResponse.json();
                const wasRunning = currentState.isRunning;

                let seconds;
                if (preset === 'bottomOfHour') {
                    // Calculate seconds to bottom of the hour (X:30)
                    const now = new Date();
                    const target = new Date(now);
                    target.setMinutes(30, 0, 0);

                    // If we're past 30 minutes, go to next hour's 30
                    if (now.getMinutes() >= 30) {
                        target.setHours(target.getHours() + 1);
                    }

                    seconds = Math.floor((target - now) / 1000);
                } else if (preset === 'topOfHour') {
                    // Calculate seconds to top of the hour (X:00)
                    const now = new Date();
                    const target = new Date(now);
                    target.setHours(target.getHours() + 1, 0, 0, 0);

                    seconds = Math.floor((target - now) / 1000);
                } else {
                    seconds = preset;
                }

                await setTimer(seconds, wasRunning);
            } catch (error) {
                console.error('Failed to set timer preset:', error);
            }
        }

        async function adjustTimer(seconds) {
            try {
                const response = await fetch('/api/timer/adjust', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ seconds })
                });
                const data = await response.json();
                updateDisplay(data.state);
            } catch (error) {
                console.error('Failed to adjust timer:', error);
            }
        }

        function parseTimeString(timeStr) {
            const parts = timeStr.trim().split(':').map(p => parseInt(p, 10));

            if (parts.length === 2) {
                // MM:SS
                return parts[0] * 60 + parts[1];
            } else if (parts.length === 3) {
                // HH:MM:SS
                return parts[0] * 3600 + parts[1] * 60 + parts[2];
            }

            return null;
        }

        function setCustomTime() {
            const input = document.getElementById('customTime');
            const timeStr = input.value;
            const seconds = parseTimeString(timeStr);

            if (seconds !== null && seconds >= 0) {
                setTimer(seconds);
                input.value = '';
            } else {
                alert('Invalid time format. Use MM:SS or HH:MM:SS');
            }
        }

        function parseTimeOfDay(timeStr) {
            // Parse 12-hour format (e.g., "2:30 PM") or 24-hour format (e.g., "14:30")
            timeStr = timeStr.trim();

            let hours, minutes;
            const ampmMatch = timeStr.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
            const twentyFourHourMatch = timeStr.match(/^(\d{1,2}):(\d{2})$/);

            if (ampmMatch) {
                // 12-hour format
                hours = parseInt(ampmMatch[1], 10);
                minutes = parseInt(ampmMatch[2], 10);
                const ampm = ampmMatch[3].toUpperCase();

                if (ampm === 'PM' && hours !== 12) {
                    hours += 12;
                } else if (ampm === 'AM' && hours === 12) {
                    hours = 0;
                }
            } else if (twentyFourHourMatch) {
                // 24-hour format
                hours = parseInt(twentyFourHourMatch[1], 10);
                minutes = parseInt(twentyFourHourMatch[2], 10);
            } else {
                return null;
            }

            if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
                return null;
            }

            return { hours, minutes };
        }

        function setCountDownToTime() {
            const input = document.getElementById('countDownTime');
            const timeStr = input.value;
            const parsedTime = parseTimeOfDay(timeStr);

            if (!parsedTime) {
                alert('Invalid time format. Use 12-hour (e.g., "2:30 PM") or 24-hour (e.g., "14:30") format');
                return;
            }

            const now = new Date();
            const target = new Date(now);
            target.setHours(parsedTime.hours, parsedTime.minutes, 0, 0);

            // If target time has already passed today, set it for tomorrow
            if (target <= now) {
                target.setDate(target.getDate() + 1);
            }

            const seconds = Math.floor((target - now) / 1000);

            if (seconds > 0) {
                setTimer(seconds);
                input.value = '';
            } else {
                alert('Time calculation error');
            }
        }

        // Update settings UI (without adding listeners)
        function updateSettingsUI() {
            const settings = settingsManager.getAll();

            // Load checkbox states
            document.getElementById('showHours').checked = settings.showHours;
            document.getElementById('showMinutes').checked = settings.showMinutes;
            document.getElementById('showSeconds').checked = settings.showSeconds;
            document.getElementById('showMilliseconds').checked = settings.showMilliseconds;
            document.getElementById('countUpAfterZero').checked = settings.countUpAfterZero;
            document.getElementById('showTimeOfDay').checked = settings.showTimeOfDay;

            // Load color values
            document.getElementById('colorNormal').value = settings.colorNormal;
            document.getElementById('colorWarning').value = settings.colorWarning;
            document.getElementById('colorCritical').value = settings.colorCritical;
        }

        // Initialize settings UI and attach event listeners (call once on startup)
        function initializeSettings() {
            updateSettingsUI();

            // Add change listeners (only once)
            ['showHours', 'showMinutes', 'showSeconds', 'showMilliseconds', 'countUpAfterZero', 'showTimeOfDay'].forEach(id => {
                document.getElementById(id).addEventListener('change', (e) => {
                    settingsManager.set(id, e.target.checked);
                    if (cachedState) {
                        updateDisplay(cachedState);
                    }
                    // Broadcast to other clients
                    broadcastSettings();
                });
            });

            ['colorNormal', 'colorWarning', 'colorCritical'].forEach(id => {
                document.getElementById(id).addEventListener('input', (e) => {
                    settingsManager.set(id, e.target.value);
                    if (cachedState) {
                        updateDisplay(cachedState);
                    }
                    // Broadcast to other clients
                    broadcastSettings();
                });
            });
        }

        // Allow Enter key to submit custom time
        document.getElementById('customTime').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                setCustomTime();
            }
        });

        // Allow Enter key to submit count down time
        document.getElementById('countDownTime').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                setCountDownToTime();
            }
        });

        // Initialize settings
        initializeSettings();

        // Send current settings to server on startup (so server state matches localStorage)
        broadcastSettings();

        // Connect to WebSocket for real-time updates
        connectWebSocket();

        // Update display locally at 10fps for smooth countdown when running
        localUpdateInterval = setInterval(updateLocalDisplay, 100);

        // Update clock every second
        setInterval(() => {
            if (cachedState) {
                updateDisplay(cachedState);
            }
        }, 1000);

        // Initial fetch (WebSocket will handle updates after this)
        fetchTimerState();
    </script>
</body>

</html>